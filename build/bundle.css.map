{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../src/App.svelte",
    "../../src/views/three.svelte",
    "../../src/components/three/ModeControl.svelte",
    "../../src/components/three/BrandControl.svelte"
  ],
  "sourcesContent": [
    "<svelte:options immutable></svelte:options>\n\n<main>\n\t<!-- <WebGL on:select={handleSelect}/> -->\n\t<Three/>\n</main>\n\n<script lang=\"ts\">import Three from './views/three.svelte';\nconst handleSelect = event => {\n    console.log('data from child: ', event.detail.data.name);\n};\n//# sourceMappingURL=App.svelte.js.map</script>\n\n<style>\n\tmain {\n\t\theight: 100%;\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\ttext-align: center;\n\t\tpadding: 0;\n\t\t/* max-width: 240px; */\n\t\tmargin: 0 auto;\n\t}\n\n\t/* h1 {\n\t\tcolor: #ff3e00;\n\t\ttext-transform: uppercase;\n\t\tfont-size: 4em;\n\t\tfont-weight: 100;\n\t} */\n\n\t@media (min-width: 640px) {\n\t\tmain {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n</style>",
    "\n\n<div class=\"container\" bind:this={container}></div>\n<ModeControl class=\".mode\"/>\n<BrandControl brands={brands} />\n\n<script lang=\"ts\">import { onMount, onDestroy } from 'svelte';\nimport * as THREE from 'three';\nimport TWEEN from '@tweenjs/tween.js';\nimport { currentMode, currentBrand } from '../stores/three.store';\nimport ModeControl from '../components/three/ModeControl.svelte';\nimport BrandControl from '../components/three/BrandControl.svelte';\nimport SceneConstructor from '../components/three/SceneConstructor.ts';\nimport { addDirectionLight, LipstickTweens, CameraTween } from '../utils/threeHelper.ts';\nimport { minMaxContainer } from '../utils/common.ts';\nimport lipstickData from '../data/data.json';\nconst l = console.log;\nconst brands = lipstickData.data.map(e => e.brand);\nlet lipsticks = lipstickData.data[0].data;\nl('init data: ', lipsticks);\nlet productPanelCenter = { x: 0, z: 0 };\nlet rgbCuboidBorder = { r: new minMaxContainer(), g: new minMaxContainer(), b: new minMaxContainer() };\nlet rgbCuboidCenter = {};\nlet hslCuboidBorder = { h: new minMaxContainer(), s: new minMaxContainer(), l: new minMaxContainer() };\nlet hslCuboidCenter = {};\nlet mode = 'product';\nlet detect = false;\nlet isFirstTween = true;\nlet minG, minL, maxG, maxL;\nlet column = 6;\nlet mouseCoord = new THREE.Vector2(0, 0);\nconst defaultCameraPos = {\n    x: -10,\n    y: 20,\n    z: -20\n};\nlet cubes = [];\nlet border = 30;\nlet intersected;\nlet cacheIntersectedColor;\nlet focused;\nconst lightColor = '#eeeeee';\nconst mutedColor = '#eeeeee';\nconst intersectColor = '#ff0000';\nlet container;\nlet canvasWidth = 800;\nlet canvasHeight = 600;\nconst { scene, renderer, camera, controls } = SceneConstructor({\n    container: { width: canvasWidth, height: canvasHeight },\n    colors: { light: lightColor, muted: mutedColor },\n    helper: false\n});\nconst clearScene = () => {\n    let arr = ['Mesh', 'DirectionalLight'];\n    let indices = [];\n    scene.children.map((obj, index) => {\n        obj.type === 'DirectionalLight' && indices.push(index);\n        obj.type === 'Mesh' && obj.toggle && indices.push(index);\n    });\n    while (indices.length) {\n        indices.sort().reverse().map(idx => scene.remove(scene.children[idx]));\n        indices = [];\n        scene.children.map((obj, index) => {\n            obj.type === 'DirectionalLight' && indices.push(index);\n            obj.type === 'Mesh' && obj.toggle && indices.push(index);\n        });\n    }\n};\nconst initModel = (src) => {\n    if (!src || !src.length)\n        return;\n    let row = 0;\n    let rows = [];\n    let greenValueArray = [];\n    let lightValueArray = [];\n    let xmin = 9999, xmax = 0, zmin = 9999, zmax = 0;\n    src.map((ls, productIndex, productArray) => {\n        ls.colors.map((color, colorIndex, colorArray) => {\n            let geometry = new THREE.BoxGeometry(1, 1, 1);\n            let material = new THREE.MeshBasicMaterial({ color: color.color_hex });\n            let cube = new THREE.Mesh(geometry, material);\n            cube.castShadow = true;\n            cube.receiveShadow = false;\n            cube.position.x = (colorIndex % column) * 2 - 5;\n            xmin = Math.min(cube.position.x, xmin);\n            xmax = Math.max(cube.position.x, xmax);\n            cube.position.z = ((colorIndex / column >> 0) + row) * 2 + 1 - 5;\n            zmin = Math.min(cube.position.z, zmin);\n            zmax = Math.max(cube.position.z, zmax);\n            cube.position.y = 0;\n            cube.name = productIndex + '-' + colorIndex + '-' + row;\n            cube.toggle = true;\n            if (productIndex % 2 && colorIndex === Math.floor(colorArray.length / 2)) {\n                let dirLight = addDirectionLight(scene, {\n                    x: (1 % column) * 20 - 5,\n                    y: 30,\n                    z: ((1 / column >> 0) + row) * 20 + 1 - 5\n                });\n                dirLight.target = cube;\n                scene.add(dirLight);\n            }\n            cubes.push(cube);\n            scene.add(cube);\n            const c = material.color;\n            for (let key in rgbCuboidBorder) {\n                rgbCuboidBorder[key].push(c[key]);\n            }\n            greenValueArray.push(c.g);\n            let hslColor = {};\n            c.getHSL(hslColor);\n            for (let key in hslCuboidBorder) {\n                hslCuboidBorder[key].push(hslColor[key]);\n            }\n            lightValueArray.push(hslColor.l);\n        });\n        rows.push(row);\n        row = row + ((ls.colors.length + 1) / column >> 0) + 1;\n    });\n    productPanelCenter = {\n        x: xmin + (xmax - xmin) / 2,\n        z: zmin + (zmax - zmin) / 2\n    };\n    minG = Math.min(...greenValueArray);\n    minL = Math.min(...lightValueArray);\n    let [rmin, rmax] = rgbCuboidBorder.r.getBorder();\n    let [gmin, gmax] = rgbCuboidBorder.g.getBorder();\n    let [bmin, bmax] = rgbCuboidBorder.b.getBorder();\n    rgbCuboidCenter = {\n        x: ((rmax + rmin - 1) * border) / 2,\n        y: (gmax + gmin - minG) * border,\n        z: (bmax + bmin) * border / 2 - border / 5\n    };\n    const pi = Math.PI;\n    let [hmin, hmax] = hslCuboidBorder.h.getBorder();\n    let [smin, smax] = hslCuboidBorder.s.getBorder();\n    let [lmin, lmax] = hslCuboidBorder.l.getBorder();\n    hslCuboidCenter = {\n        x: (Math.sin(2 * pi * hmax) + Math.sin(2 * pi * hmin)) * border / 2\n    };\n};\nconst raycaster = new THREE.Raycaster();\nconst raycasterHandler = (mouseCoord) => {\n    raycaster.setFromCamera(mouseCoord, camera);\n    let intersections = raycaster.intersectObjects(cubes);\n    if (intersections.length > 0) {\n        if (intersections[0].object.name !== 'floor') {\n            if (intersected !== intersections[0].object) {\n                intersected = intersections[0].object;\n                focused = intersections[0].object.name;\n                let [product, color, _] = focused.split('-');\n                l('focus: ', lipsticks[product].colors[color]);\n            }\n            container.style.cursor = 'pointer';\n        }\n    }\n    else if (intersected) {\n        intersected = null;\n        focused = null;\n        container.style.cursor = 'auto';\n    }\n};\nconst render = () => {\n    renderer.render(scene, camera);\n};\nconst animate = () => {\n    requestAnimationFrame(animate);\n    TWEEN.update();\n    controls.update();\n    render();\n};\nconst onMouseClick = (e) => {\n};\nconst canvasSizeFit = () => {\n    let { offsetWidth: width, offsetHeight: height } = container;\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n};\ncurrentBrand.subscribe(value => {\n    if (value < 0)\n        return;\n    clearScene();\n    const newData = lipstickData.data[value].data;\n    initModel(newData);\n});\nonMount(() => {\n    canvasSizeFit();\n    initModel(lipsticks);\n    container.appendChild(renderer.domElement);\n    window.addEventListener('resize', canvasSizeFit, false);\n    animate();\n});\nonDestroy(() => {\n    unsubscribe();\n    container.removeEventListener('mousemove', onMouseClick, false);\n    window.removeEventListener('resize', canvasSizeFit, false);\n});\nconst tweenLayout = (type, duration) => {\n    TWEEN.removeAll();\n    for (let i = 0; i < cubes.length; i++) {\n        let object = cubes[i];\n        const color = object.material.color;\n        let hslColor = { h: null, s: null, l: null };\n        color.getHSL(hslColor);\n        switch (type) {\n            case 'rgb': {\n                LipstickTweens.RGB(object.position, color, minG, border);\n                break;\n            }\n            case 'hsl': {\n                LipstickTweens.HSL(object.position, hslColor, minL, border);\n                break;\n            }\n            case 'product': {\n                let colorIndex = object.name.split('-')[1] - 0;\n                let row = object.name.split('-')[2] - 0;\n                LipstickTweens.Product(object.position, colorIndex, column, row);\n                break;\n            }\n        }\n    }\n    let from = {\n        x: camera.position.x,\n        y: camera.position.y,\n        z: camera.position.z\n    };\n    switch (type) {\n        case 'product': {\n            CameraTween(controls, camera, from, Object.assign({}, productPanelCenter, { y: 50 }), Object.assign({}, productPanelCenter, { y: 0 }));\n            break;\n        }\n        case 'rgb': {\n            CameraTween(controls, camera, from, Object.assign({}, rgbCuboidCenter, { y: 10, z: -50 }), Object.assign({}, rgbCuboidCenter, { y: 10, z: 0 }));\n            break;\n        }\n        case 'hsl': {\n            CameraTween(controls, camera, from, Object.assign({}, hslCuboidCenter, { y: 10, z: -40 }), Object.assign({}, hslCuboidCenter, { y: 10, z: 0 }));\n        }\n    }\n};\nconst unsubscribe = currentMode.subscribe(value => {\n    mode = value;\n    if (isFirstTween) {\n        isFirstTween = false;\n        return;\n    }\n    tweenLayout(value, 2000);\n});\n//# sourceMappingURL=three.svelte.js.map</script>\n\n<style>\n  .container {\n    z-index:1;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n  }\n</style>",
    "<div class=\"mode-control\">\n{#each modes as mode (mode)}\n  <button class=\"mode-btn\" on:click={e => handleModeChange(mode)}>{mode}</button>\n{/each}\n</div>\n\n<script lang=\"ts\">import { currentMode } from '../../stores/three.store';\nlet modes = [\n    'product',\n    'rgb',\n    'hsl'\n];\nconst handleModeChange = (mode) => {\n    currentMode.update(() => mode);\n};\n//# sourceMappingURL=ModeControl.svelte.js.map</script>\n\n<style>\n  .mode-control {\n    /* padding-top: 20px; */\n    position:absolute;\n    bottom: 20px;\n    left: 50%;\n    transform: translateX(-50%);\n    z-index:2;\n    /* border: 1px solid black; */\n    display: flex;\n    justify-content: center;\n  }\n\n  .mode-btn {\n    margin: 0 10px;\n  }\n</style>",
    "<div class=\"brand-control\">\n{#each brands as brand, index}\n  <button class=\"brand-btn\" on:click={e => handleModeChange(index)}>{brand}</button>\n{/each}\n</div>\n\n<script lang=\"ts\">import { currentBrand } from '../../stores/three.store';\nexport let brands;\nconst handleModeChange = (i) => {\n    currentBrand.update(() => i);\n};\n//# sourceMappingURL=BrandControl.svelte.js.map</script>\n\n<style>\n  .brand-control {\n    /* padding-top: 90px; */\n    position:absolute;\n    left: 0;\n    top: 0;\n    z-index:3;\n    /* border: 1px solid black; */\n    display: flex;\n    flex-direction: column;\n    /* justify-content: center; */\n  }\n\n  .brand-btn {\n    margin: 10px;\n  }\n</style>"
  ],
  "names": [],
  "mappings": "AAcC,IAAI,eAAC,CAAC,AACL,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,CAAC,CAEV,MAAM,CAAE,CAAC,CAAC,IAAI,AACf,CAAC,AASD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,IAAI,eAAC,CAAC,AACL,SAAS,CAAE,IAAI,AAChB,CAAC,AACF,CAAC;ACwNA,UAAU,cAAC,CAAC,AACV,QAAQ,CAAC,CACT,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,MAAM,CAAE,CAAC,CACT,KAAK,CAAE,CAAC,AACV,CAAC;AChPD,aAAa,eAAC,CAAC,AAEb,SAAS,QAAQ,CACjB,MAAM,CAAE,IAAI,CACZ,IAAI,CAAE,GAAG,CACT,SAAS,CAAE,WAAW,IAAI,CAAC,CAC3B,QAAQ,CAAC,CAET,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,AACzB,CAAC,AAED,SAAS,eAAC,CAAC,AACT,MAAM,CAAE,CAAC,CAAC,IAAI,AAChB,CAAC;AClBD,cAAc,cAAC,CAAC,AAEd,SAAS,QAAQ,CACjB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,QAAQ,CAAC,CAET,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AAExB,CAAC,AAED,UAAU,cAAC,CAAC,AACV,MAAM,CAAE,IAAI,AACd,CAAC"
}